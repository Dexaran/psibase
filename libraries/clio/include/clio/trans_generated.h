// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_TRANS_CLIOFB_H_
#define FLATBUFFERS_GENERATED_TRANS_CLIOFB_H_

#include "flatbuffers/flatbuffers.h"

namespace cliofb
{

   struct transfer;
   struct transferBuilder;

   struct action;
   struct actionBuilder;

   struct transaction;
   struct transactionBuilder;

   struct transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
   {
      typedef transferBuilder      Builder;
      enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
      {
         VT_FROM   = 4,
         VT_TO     = 6,
         VT_AMOUNT = 8,
         VT_MEMO   = 10
      };
      uint32_t                   from() const { return GetField<uint32_t>(VT_FROM, 0); }
      uint32_t                   to() const { return GetField<uint32_t>(VT_TO, 0); }
      uint64_t                   amount() const { return GetField<uint64_t>(VT_AMOUNT, 0); }
      const flatbuffers::String* memo() const
      {
         return GetPointer<const flatbuffers::String*>(VT_MEMO);
      }
      bool Verify(flatbuffers::Verifier& verifier) const
      {
         return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_FROM, 4) &&
                VerifyField<uint32_t>(verifier, VT_TO, 4) &&
                VerifyField<uint64_t>(verifier, VT_AMOUNT, 8) && VerifyOffset(verifier, VT_MEMO) &&
                verifier.VerifyString(memo()) && verifier.EndTable();
      }
   };

   struct transferBuilder
   {
      typedef transfer                Table;
      flatbuffers::FlatBufferBuilder& fbb_;
      flatbuffers::uoffset_t          start_;
      void add_from(uint32_t from) { fbb_.AddElement<uint32_t>(transfer::VT_FROM, from, 0); }
      void add_to(uint32_t to) { fbb_.AddElement<uint32_t>(transfer::VT_TO, to, 0); }
      void add_amount(uint64_t amount)
      {
         fbb_.AddElement<uint64_t>(transfer::VT_AMOUNT, amount, 0);
      }
      void add_memo(flatbuffers::Offset<flatbuffers::String> memo)
      {
         fbb_.AddOffset(transfer::VT_MEMO, memo);
      }
      explicit transferBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
      {
         start_ = fbb_.StartTable();
      }
      flatbuffers::Offset<transfer> Finish()
      {
         const auto end = fbb_.EndTable(start_);
         auto       o   = flatbuffers::Offset<transfer>(end);
         return o;
      }
   };

   inline flatbuffers::Offset<transfer> Createtransfer(
       flatbuffers::FlatBufferBuilder&          _fbb,
       uint32_t                                 from   = 0,
       uint32_t                                 to     = 0,
       uint64_t                                 amount = 0,
       flatbuffers::Offset<flatbuffers::String> memo   = 0)
   {
      transferBuilder builder_(_fbb);
      builder_.add_amount(amount);
      builder_.add_memo(memo);
      builder_.add_to(to);
      builder_.add_from(from);
      return builder_.Finish();
   }

   inline flatbuffers::Offset<transfer> CreatetransferDirect(flatbuffers::FlatBufferBuilder& _fbb,
                                                             uint32_t    from   = 0,
                                                             uint32_t    to     = 0,
                                                             uint64_t    amount = 0,
                                                             const char* memo   = nullptr)
   {
      auto memo__ = memo ? _fbb.CreateString(memo) : 0;
      return cliofb::Createtransfer(_fbb, from, to, amount, memo__);
   }

   struct action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
   {
      typedef actionBuilder        Builder;
      enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
      {
         VT_SENDER   = 4,
         VT_CONTRACT = 6,
         VT_ACT      = 8,
         VT_DATA     = 10
      };
      uint32_t sender() const { return GetField<uint32_t>(VT_SENDER, 0); }
      uint32_t contract() const { return GetField<uint32_t>(VT_CONTRACT, 0); }
      uint32_t act() const { return GetField<uint32_t>(VT_ACT, 0); }
      const flatbuffers::Vector<uint8_t>* data() const
      {
         return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_DATA);
      }
      bool Verify(flatbuffers::Verifier& verifier) const
      {
         return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_SENDER, 4) &&
                VerifyField<uint32_t>(verifier, VT_CONTRACT, 4) &&
                VerifyField<uint32_t>(verifier, VT_ACT, 4) && VerifyOffset(verifier, VT_DATA) &&
                verifier.VerifyVector(data()) && verifier.EndTable();
      }
   };

   struct actionBuilder
   {
      typedef action                  Table;
      flatbuffers::FlatBufferBuilder& fbb_;
      flatbuffers::uoffset_t          start_;
      void add_sender(uint32_t sender) { fbb_.AddElement<uint32_t>(action::VT_SENDER, sender, 0); }
      void add_contract(uint32_t contract)
      {
         fbb_.AddElement<uint32_t>(action::VT_CONTRACT, contract, 0);
      }
      void add_act(uint32_t act) { fbb_.AddElement<uint32_t>(action::VT_ACT, act, 0); }
      void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data)
      {
         fbb_.AddOffset(action::VT_DATA, data);
      }
      explicit actionBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
      {
         start_ = fbb_.StartTable();
      }
      flatbuffers::Offset<action> Finish()
      {
         const auto end = fbb_.EndTable(start_);
         auto       o   = flatbuffers::Offset<action>(end);
         return o;
      }
   };

   inline flatbuffers::Offset<action> Createaction(
       flatbuffers::FlatBufferBuilder&                   _fbb,
       uint32_t                                          sender   = 0,
       uint32_t                                          contract = 0,
       uint32_t                                          act      = 0,
       flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data     = 0)
   {
      actionBuilder builder_(_fbb);
      builder_.add_data(data);
      builder_.add_act(act);
      builder_.add_contract(contract);
      builder_.add_sender(sender);
      return builder_.Finish();
   }

   inline flatbuffers::Offset<action> CreateactionDirect(flatbuffers::FlatBufferBuilder& _fbb,
                                                         uint32_t                        sender = 0,
                                                         uint32_t                    contract   = 0,
                                                         uint32_t                    act        = 0,
                                                         const std::vector<uint8_t>* data = nullptr)
   {
      auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
      return cliofb::Createaction(_fbb, sender, contract, act, data__);
   }

   struct transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
   {
      typedef transactionBuilder   Builder;
      enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
      {
         VT_ACTIONS = 4
      };
      const flatbuffers::Vector<flatbuffers::Offset<cliofb::action>>* actions() const
      {
         return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<cliofb::action>>*>(
             VT_ACTIONS);
      }
      bool Verify(flatbuffers::Verifier& verifier) const
      {
         return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ACTIONS) &&
                verifier.VerifyVector(actions()) && verifier.VerifyVectorOfTables(actions()) &&
                verifier.EndTable();
      }
   };

   struct transactionBuilder
   {
      typedef transaction             Table;
      flatbuffers::FlatBufferBuilder& fbb_;
      flatbuffers::uoffset_t          start_;
      void                            add_actions(
                                     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<cliofb::action>>> actions)
      {
         fbb_.AddOffset(transaction::VT_ACTIONS, actions);
      }
      explicit transactionBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
      {
         start_ = fbb_.StartTable();
      }
      flatbuffers::Offset<transaction> Finish()
      {
         const auto end = fbb_.EndTable(start_);
         auto       o   = flatbuffers::Offset<transaction>(end);
         return o;
      }
   };

   inline flatbuffers::Offset<transaction> Createtransaction(
       flatbuffers::FlatBufferBuilder&                                               _fbb,
       flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<cliofb::action>>> actions = 0)
   {
      transactionBuilder builder_(_fbb);
      builder_.add_actions(actions);
      return builder_.Finish();
   }

   inline flatbuffers::Offset<transaction> CreatetransactionDirect(
       flatbuffers::FlatBufferBuilder&                         _fbb,
       const std::vector<flatbuffers::Offset<cliofb::action>>* actions = nullptr)
   {
      auto actions__ =
          actions ? _fbb.CreateVector<flatbuffers::Offset<cliofb::action>>(*actions) : 0;
      return cliofb::Createtransaction(_fbb, actions__);
   }

   inline const cliofb::transaction* Gettransaction(const void* buf)
   {
      return flatbuffers::GetRoot<cliofb::transaction>(buf);
   }

   inline const cliofb::transaction* GetSizePrefixedtransaction(const void* buf)
   {
      return flatbuffers::GetSizePrefixedRoot<cliofb::transaction>(buf);
   }

   inline bool VerifytransactionBuffer(flatbuffers::Verifier& verifier)
   {
      return verifier.VerifyBuffer<cliofb::transaction>(nullptr);
   }

   inline bool VerifySizePrefixedtransactionBuffer(flatbuffers::Verifier& verifier)
   {
      return verifier.VerifySizePrefixedBuffer<cliofb::transaction>(nullptr);
   }

   inline void FinishtransactionBuffer(flatbuffers::FlatBufferBuilder&          fbb,
                                       flatbuffers::Offset<cliofb::transaction> root)
   {
      fbb.Finish(root);
   }

   inline void FinishSizePrefixedtransactionBuffer(flatbuffers::FlatBufferBuilder&          fbb,
                                                   flatbuffers::Offset<cliofb::transaction> root)
   {
      fbb.FinishSizePrefixed(root);
   }

}  // namespace cliofb

#endif  // FLATBUFFERS_GENERATED_TRANS_CLIOFB_H_
