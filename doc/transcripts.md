# Transcripts

In most blockchains, every function called on an on-chain smart-contract is called a "transaction." In EOSIO-based blockchains, calling a function on chain requires one "action," and a "transaction" may be comprised of one or many such actions. In this way, a transaction can be viewed as a kind of "script" with one very basic capability: execute an ordered list of actions.

In Psibase, the concept of a script has been generalized, and is known as a "transcript." Psibase blockchains still use ordered lists of actions in transactions like EOSIO blockchains, but some actions may themselves be written to execute an ordered list of other actions. Such actions are called transcripts. What differentiates transcripts from regular actions that call other inline actions is that a transcript is permitted to execute inline actions as the user who signed the originating transaction, as opposed to regular actions which are only able to execute inline actions in the context of the running contract.

## Use case

An applet may pack several actions into a single transaction to execute one overall user-initiated operation. But consider the case where the intermediate value of one action is required as a parameter for a subsequent action. Without transcripts, it would be required that the execution of this operation be split into two separate transactions, and the client would need to read the intermediate state from the chain before submitting the second transaction.

In Psibase blockchains, a transcript may be written to bundle all the actions together as inline-actions. Intermediate state or return values of prior actions can be read and fed into subsequent actions within the transcript, and all inline actions executed may run as the user, as though they were submitted as part of an overall transaction.

### Example

Consider an applet that wants to create a new token with a symbol. A user is presented with a form that lets them select the properties of the new token, the name of the symbol, and a button labeled, "Create."

To accomplish this, the following steps would be required:
1. create@token-sys: Create a new token
2. Look up the nft created by the token contract that represents ownership of the new token
3. debit@nft-sys: Debit the token nft
4. Look up how much a new symbol costs
5. credit@token-sys: Send the cost of a new symbol to the symbol contract
6. create@symbol-sys: Tell the symbol contract to create a new symbol (it will debit the tokens sent in the previous step)
7. Look up the NFT generated that represents the ownership of the new symbol
8. debit@nft-sys: Debit the symbol NFT
9. credit@nft-sys: Transfer the symbol NFT back to the symbol contract
10. Look up the ID of the newly created token
11. mapToken@symbol: Map the symbol to the new token ID

Notice that the lookup in steps 2 and 7 each require that prior actions were completed, and are required to run the rest of the actions in this sequence. Regardless of any arrangement of these actions and operations, the minimum number of transactions required to run this sequence without transcripts would be 2. The second transaction could not even be constructed until the first one completed. This delay means various user errors could result in partial execution of the sequence, leaving the user with a token without a symbol, or a symbol without a token.

With transcripts, the entire sequence can be shrunk down to:
1. Look up how much a new symbol costs
2. credit@token-sys: Send the cost of a new symbol to the symbol contract
3. create@symbol-sys: Create a new symbol
4. createAndMap@tokenSys: Creates a new token, and map it to the newly created symbol

This sequence contains only three actions which can be fit in a single transaction which will execute atomically. 

To implement the createAndMap@tokenSys transcript, the c++ code would be significantly simpler, due to the ability to receive action return values.

```cpp
// tokenSys.cpp (pseudocode)

void TokenSys::createAndMap(Precision p, Quantity maxSupply, SID symbolId)
{
    // Create new token, and give ownership to sender
    auto tid = create(p, maxSupply);
    auto tokenNft = getToken(tid).ownerNft;
    senderAt<NftSys>().debit(tokenNft, "Debit token ownership NFT");

    // Create new symbol
    auto cost = at<SymbolSys>().getCost(symbolId.str().size());
    senderAt<SymbolSys>().create(symbolId, cost);
    auto symbolNft = at<SymbolSys>().getSymbol(symbolId).ownerNft;
    senderAt<NftSys>().debit(symbolNft, "Take ownership of new symbol");

    // Map symbol to token
    senderAt<NftSys>().credit(symbolNft, SymbolSys::contract, "Give symbol to symbol-sys");
    senderAt<SymbolSys>().mapToken(tid, symbolId);
}

```

# Conclusion

Transcripts allow application developers to provide a special interface to applets that abstract the complexity of running transactions that contain actions dependent on the state update generated by the successful execution of prior actions.

The ability to run such sequences atomically means that they will all fail or succeed together, ensuring that the user is not left in a partially completed state. Transcripts therefore reduce errors and increase developer and user experience.
