use clap::{Parser, Subcommand};
use mdbook::preprocess::CmdPreprocessor;
use mdbook::BookItem;
use regex::{Captures, Regex};
use std::cmp::max;
use std::collections::HashMap;
use std::path::Path;
use std::{fs, io};
use yaml_rust::{Yaml, YamlLoader};

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Supports { renderer: String },
}

#[derive(Copy, Clone)]
enum Type {
    Namespace,
    Function,
    Record,
}

struct Item {
    yaml_index: usize,
    name: String,
    full_name: String,
    _ty: Type,
    doc_str: String,
    url: String,
    parent: Option<usize>,
    children: Vec<usize>,
}

// Load .yaml files in filesystem tree. Assumes they were generated by clang-doc.
fn load_yamls(dir: &Path, yamls: &mut Vec<Yaml>) -> io::Result<()> {
    if dir.is_dir() {
        for entry in fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                load_yamls(&path, yamls)?;
            } else {
                yamls.append(
                    &mut YamlLoader::load_from_str(
                        &fs::read_to_string(entry.path().to_str().unwrap()).unwrap(),
                    )
                    .unwrap(),
                );
            }
        }
    }
    Ok(())
}

// Convert comments to markdown. Assumes any formatting within the comments are
// compatible with markdown (doesn't escape).
fn convert_doc_str(yaml: &Yaml) -> String {
    let mut result = String::new();
    let empty = Vec::new();
    for a in yaml["Description"].as_vec().unwrap_or(&empty).iter() {
        if a["Kind"].as_str().unwrap_or("") == "FullComment" {
            for b in a["Children"].as_vec().unwrap_or(&empty).iter() {
                if b["Kind"].as_str().unwrap_or("") == "ParagraphComment" {
                    for c in b["Children"].as_vec().unwrap_or(&empty).iter() {
                        if c["Kind"].as_str().unwrap_or("") == "TextComment" {
                            let mut line = c["Text"].as_str().unwrap_or("");
                            if !line.is_empty() && *line.as_bytes().get(0).unwrap() == b' ' {
                                line = &line[1..];
                            }
                            result.push_str(line);
                            result.push('\n');
                        }
                    }
                    result.push('\n');
                }
            }
        }
    }
    result
}

// Looks up a yaml by USR. If found, add it to items. Recurses into children.
fn convert_item<'a>(
    yamls: &'a mut Vec<Yaml>,
    yamls_by_usr: &'a mut HashMap<String, usize>,
    items: &'a mut Vec<Item>,
    items_by_usr: &'a mut HashMap<String, usize>,
    parent: Option<usize>,
    ty: Type,
    usr: &str,
) -> Option<usize> {
    let mut ancestor = parent;
    while let Some(x) = ancestor {
        if yamls[items[x].yaml_index]["USR"].as_str().unwrap() == usr {
            return None;
        }
        ancestor = items[x].parent;
    }
    if let Some(i) = yamls_by_usr.get(usr) {
        let i = *i;
        let name;
        let full_name;
        if let Some(parent) = parent {
            name = yamls[i]["Name"].as_str().unwrap_or("").to_owned();
            full_name = items[parent].full_name.clone() + "::" + &name;
        } else {
            name = String::new();
            full_name = String::new();
        }
        let index = items.len();
        items.push(Item {
            yaml_index: i,
            name,
            full_name,
            _ty: ty,
            doc_str: convert_doc_str(&yamls[i]),
            url: String::new(),
            parent,
            children: Vec::new(),
        });
        items_by_usr.insert(usr.to_owned(), items.len() - 1);
        convert_items(
            yamls,
            yamls_by_usr,
            items,
            items_by_usr,
            index,
            i,
            "ChildNamespaces",
            Type::Namespace,
            false,
        );
        convert_items(
            yamls,
            yamls_by_usr,
            items,
            items_by_usr,
            index,
            i,
            "ChildRecords",
            Type::Function,
            false,
        );
        convert_items(
            yamls,
            yamls_by_usr,
            items,
            items_by_usr,
            index,
            i,
            "ChildFunctions",
            Type::Record,
            true,
        );
        Some(index)
    } else {
        None
    }
} // convert_item

// Convert children of a yaml
#[allow(clippy::too_many_arguments)]
fn convert_items<'a>(
    yamls: &'a mut Vec<Yaml>,
    yamls_by_usr: &'a mut HashMap<String, usize>,
    items: &'a mut Vec<Item>,
    items_by_usr: &'a mut HashMap<String, usize>,
    parent: usize,
    children_in_index: usize,
    children_name: &str,
    ty: Type,
    create_children: bool,
) {
    let empty = Vec::new();
    for x in yamls[children_in_index][children_name]
        .clone()
        .as_vec()
        .unwrap_or(&empty)
        .iter()
    {
        let usr = x["USR"].as_str().unwrap();
        if create_children && yamls_by_usr.get(usr).is_none() {
            yamls.push(x.clone());
            yamls_by_usr.insert(usr.to_owned(), yamls.len() - 1);
        }
        if let Some(index) = convert_item(
            yamls,
            yamls_by_usr,
            items,
            items_by_usr,
            Some(parent),
            ty,
            usr,
        ) {
            items[parent].children.push(index);
        }
    }
}

// Look up item by path and fill result. There may be multiple matches (e.g. function overloads).
fn lookup<'a>(
    yamls: &'a Vec<Yaml>,
    items: &Vec<Item>,
    parent: usize,
    path: &[&str],
    recursed: bool,
    result: &mut Vec<usize>,
) {
    if path.is_empty() {
        if recursed {
            result.push(parent);
        }
        return;
    }
    let item = &items[parent];
    for child_index in &item.children {
        if items[*child_index].name == path[0] {
            lookup(yamls, items, *child_index, &path[1..], true, result);
        }
    }
    if result.is_empty() && !recursed {
        if let Some(grandparent) = item.parent {
            lookup(yamls, items, grandparent, path, recursed, result);
        }
    }
}

// Set the url field of every item embedded in a chapter
fn set_urls<'a>(
    chapter: &mdbook::book::Chapter,
    yamls: &'a Vec<Yaml>,
    items: &mut Vec<Item>,
    global_namespace: usize,
    path: &str,
) {
    let mut chapter_path = chapter
        .path
        .clone()
        .unwrap()
        .to_str()
        .unwrap()
        .replace(".md", ".html");
    chapter_path.insert(0, '/');
    let mut indexes = Vec::new();
    lookup(
        yamls,
        items,
        global_namespace,
        &path
            .split("::")
            .filter(|s| !s.is_empty())
            .collect::<Vec<&str>>(),
        false,
        &mut indexes,
    );
    for index in indexes {
        let item = &mut items[index];
        let mut link_name = item.full_name.replace("::", "");
        link_name.make_ascii_lowercase();
        item.url = chapter_path.clone() + "#" + &link_name;
        // eprintln!("{:?}", item.url);
    }
}

// Replace text of the form "foo" or "foo::bar::baz" with a link
fn fill_link<'a>(
    text: &str,
    yamls: &'a Vec<Yaml>,
    items: &Vec<Item>,
    parent: usize,
) -> Option<String> {
    let mut candidates = Vec::new();
    lookup(
        yamls,
        items,
        parent,
        &text
            .split("::")
            .filter(|s| !s.is_empty())
            .collect::<Vec<&str>>(),
        false,
        &mut candidates,
    );
    if !candidates.is_empty() {
        Some(String::new() + "[" + text + "](" + &items[candidates[0]].url + ")")
    } else {
        None
    }
}

// Replace all occurrences of the form "[foo]" or "[foo::bar::baz]" with a link. Leaves
// "[...](...)" untouched.
fn fill_all_links<'a>(
    text: &str,
    yamls: &'a Vec<Yaml>,
    items: &Vec<Item>,
    parent: usize,
) -> String {
    let re = Regex::new(r"[\[]([^\]\n]+)[\]]([(][^)]*[)])?").unwrap();
    re.replace_all(text, |caps: &Captures| {
        if caps.get(2).is_some() {
            caps.get(0).unwrap().as_str().to_owned()
        } else {
            let str = caps.get(1).unwrap().as_str();
            let link = fill_link(str, yamls, items, parent);
            if let Some(link) = link {
                link
            } else {
                caps.get(0).unwrap().as_str().to_owned()
            }
        }
    })
    .into_owned()
}

fn expand_type(items: &[Item], items_by_usr: &HashMap<String, usize>, yaml: &Yaml) -> String {
    if let Some(usr) = yaml["USR"].as_str() {
        if let Some(index) = items_by_usr.get(usr) {
            let mut item = &items[*index];
            let mut name = item.name.clone();
            while let Some(parent) = item.parent {
                item = &items[parent];
                name = item.name.clone() + "::" + &name;
            }
            if name.starts_with("::") {
                name.replace_range(..2, "");
            }
            return name;
        }
    }
    let mut result = yaml["Name"]
        .as_str()
        .unwrap_or("")
        .to_owned()
        .replace("enum ", "")
        .replace("struct ", "");
    if result == "_Bool" {
        result = "bool".to_owned();
    }
    if let Some(path) = yaml["Path"].as_str() {
        result = path.replace('/', "::") + "::" + &result;
    }
    result
        .replace("std::__1::", "std::")
        .replace("std::__2::", "std::")
}

// Generate documentation for matching items
fn generate_documentation(
    yamls: &Vec<Yaml>,
    items: &Vec<Item>,
    items_by_usr: &HashMap<String, usize>,
    global_namespace: usize,
    path: &str,
) -> String {
    let empty = Vec::new();
    let mut found_indexes = Vec::new();
    lookup(
        yamls,
        items,
        global_namespace,
        &path
            .split("::")
            .filter(|s| !s.is_empty())
            .collect::<Vec<&str>>(),
        false,
        &mut found_indexes,
    );

    if found_indexes.is_empty() {
        panic!("{} not found", path);
    }

    let mut result = String::new();
    for index in found_indexes {
        let item = &items[index];

        let mut def = String::new();
        def.push_str("```text\n");
        def.push_str(&expand_type(
            items,
            items_by_usr,
            &yamls[item.yaml_index]["ReturnType"]["Type"],
        ));
        def.push(' ');
        def.push_str(&path[2..]);
        def.push('(');
        let params = yamls[item.yaml_index]["Params"].as_vec().unwrap_or(&empty);
        let mut type_size = 0usize;
        for param in params.iter() {
            type_size = max(
                type_size,
                expand_type(items, items_by_usr, &param["Type"]).len(),
            );
        }
        let mut need_comma = false;
        for param in params.iter() {
            if need_comma {
                def.push(',');
            }
            def.push_str("\n    ");
            def.push_str(&format!(
                "{:1$}",
                expand_type(items, items_by_usr, &param["Type"]),
                type_size + 1
            ));
            def.push_str(param["Name"].as_str().unwrap_or(""));
            need_comma = true;
        }
        if need_comma {
            def.push('\n');
        }
        def.push_str(");\n");
        def.push_str("```\n");

        result.push_str(&format!(
            "### {}\n\n{}\n{}\n",
            &path[2..],
            def,
            fill_all_links(&item.doc_str, yamls, items, index)
        ));
    }
    result
} // generate_documentation

fn main() -> Result<(), anyhow::Error> {
    let re = Regex::new(r"[{][{] *#cpp-doc +(::[^ ]+)+ *[}][}]").unwrap();
    let args = Args::parse();
    if args.command.is_some() {
        return Ok(());
    }

    let (ctx, mut book) = CmdPreprocessor::parse_input(io::stdin())?;
    let mut path = ctx.root;
    path.push("../../build/doc-wasm");
    let mut yamls = Vec::new();
    load_yamls(&path, &mut yamls)?;
    let mut yamls_by_usr = HashMap::new();
    for (i, x) in yamls.iter().enumerate() {
        yamls_by_usr.insert(x["USR"].as_str().unwrap().to_owned(), i);
    }

    let mut items = Vec::new();
    let mut items_by_usr = HashMap::new();
    let global_namespace = convert_item(
        &mut yamls,
        &mut yamls_by_usr,
        &mut items,
        &mut items_by_usr,
        None,
        Type::Namespace,
        "0000000000000000000000000000000000000000",
    );
    if let Some(global_namespace) = global_namespace {
        for item in book.iter() {
            match item {
                BookItem::Chapter(chapter) => {
                    for capture in re.captures_iter(&chapter.content) {
                        let path = capture.get(1).unwrap().as_str();
                        set_urls(chapter, &yamls, &mut items, global_namespace, path);
                    }
                }
                BookItem::Separator => (),
                BookItem::PartTitle(_) => (),
            }
        }
        book.for_each_mut(|item: &mut BookItem| match item {
            BookItem::Chapter(chapter) => {
                chapter.content = re
                    .replace_all(&chapter.content, |caps: &Captures| {
                        let path = caps.get(1).unwrap().as_str();
                        generate_documentation(
                            &yamls,
                            &items,
                            &items_by_usr,
                            global_namespace,
                            path,
                        )
                    })
                    .to_string();
            }
            BookItem::Separator => (),
            BookItem::PartTitle(_) => (),
        });
    }

    serde_json::to_writer(io::stdout(), &book)?;

    Ok(())
} // main
